-- =============================================
-- STEP 1: CORE TABLES (No Dependencies)
-- =============================================

-- 1. PROFILES TABLE (extends auth.users)
CREATE TABLE profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
  email TEXT UNIQUE NOT NULL,
  full_name TEXT,
  avatar_url TEXT,
  phone TEXT,
  department TEXT,
  role TEXT CHECK (role IN ('admin', 'hr', 'manager', 'employee', 'client')) DEFAULT 'employee',
  status TEXT CHECK (status IN ('active', 'inactive', 'suspended')) DEFAULT 'active',
  hire_date DATE,
  employee_id TEXT UNIQUE,
  address TEXT,
  email_verified BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. EMAIL OTP CODES TABLE (Updated for email-based OTP)
CREATE TABLE email_otp_codes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  email TEXT NOT NULL,
  otp_code TEXT NOT NULL,
  purpose TEXT CHECK (purpose IN ('signup', 'email_verification', 'password_reset', 'login')) NOT NULL,
  is_verified BOOLEAN DEFAULT FALSE,
  attempt_count INTEGER DEFAULT 0,
  max_attempts INTEGER DEFAULT 5,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  verified_at TIMESTAMPTZ,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE -- Link to user for password reset
);

-- 3. PASSWORD RESET TOKENS TABLE (Additional security for password reset)
CREATE TABLE password_reset_tokens (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  token TEXT UNIQUE NOT NULL,
  otp_id UUID REFERENCES email_otp_codes(id) ON DELETE CASCADE,
  is_used BOOLEAN DEFAULT FALSE,
  expires_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  used_at TIMESTAMPTZ
);

-- Enable RLS
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE email_otp_codes ENABLE ROW LEVEL SECURITY;
ALTER TABLE password_reset_tokens ENABLE ROW LEVEL SECURITY;

-- Basic indexes
CREATE INDEX idx_profiles_role ON profiles(role);
CREATE INDEX idx_profiles_status ON profiles(status);
CREATE INDEX idx_profiles_employee_id ON profiles(employee_id);
CREATE INDEX idx_profiles_email ON profiles(email);
CREATE INDEX idx_email_otp_codes_email ON email_otp_codes(email);
CREATE INDEX idx_email_otp_codes_purpose ON email_otp_codes(purpose);
CREATE INDEX idx_email_otp_codes_expires_at ON email_otp_codes(expires_at);
CREATE INDEX idx_password_reset_tokens_token ON password_reset_tokens(token);
CREATE INDEX idx_password_reset_tokens_user_id ON password_reset_tokens(user_id);

-- =============================================
-- STEP 2: PROJECT MANAGEMENT TABLES
-- =============================================

-- 1. PROJECTS TABLE
CREATE TABLE projects (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT CHECK (status IN ('planning', 'active', 'on_hold', 'completed', 'cancelled')) DEFAULT 'planning',
  priority TEXT CHECK (priority IN ('low', 'medium', 'high', 'urgent')) DEFAULT 'medium',
  visibility TEXT CHECK (visibility IN ('public', 'private')) DEFAULT 'public',
  start_date DATE,
  end_date DATE,
  budget DECIMAL(12,2),
  created_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  assigned_to UUID REFERENCES profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. TASKS TABLE
CREATE TABLE tasks (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT CHECK (status IN ('todo', 'in_progress', 'review', 'done', 'cancelled')) DEFAULT 'todo',
  priority TEXT CHECK (priority IN ('low', 'medium', 'high', 'urgent')) DEFAULT 'medium',
  assigned_to UUID REFERENCES profiles(id) ON DELETE SET NULL,
  created_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  due_date TIMESTAMPTZ,
  estimated_hours INTEGER,
  actual_hours INTEGER DEFAULT 0,
  tags TEXT[],
  position INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. TASK COMMENTS TABLE
CREATE TABLE task_comments (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  mentions UUID[],
  attachments TEXT[],
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 4. PROJECT MEMBERS TABLE
CREATE TABLE project_members (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  role TEXT CHECK (role IN ('owner', 'admin', 'member', 'viewer')) DEFAULT 'member',
  added_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  added_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(project_id, user_id)
);

-- Enable RLS
ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY;
ALTER TABLE project_members ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_projects_status ON projects(status);
CREATE INDEX idx_projects_created_by ON projects(created_by);
CREATE INDEX idx_projects_assigned_to ON projects(assigned_to);
CREATE INDEX idx_tasks_project_id ON tasks(project_id);
CREATE INDEX idx_tasks_assigned_to ON tasks(assigned_to);
CREATE INDEX idx_tasks_status ON tasks(status);
CREATE INDEX idx_tasks_due_date ON tasks(due_date);

-- =============================================
-- STEP 3: HR MANAGEMENT TABLES
-- =============================================

-- 1. ATTENDANCE TABLE
CREATE TABLE attendance (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  check_in TIMESTAMPTZ,
  check_out TIMESTAMPTZ,
  break_start TIMESTAMPTZ,
  break_end TIMESTAMPTZ,
  total_hours DECIMAL(4,2),
  status TEXT CHECK (status IN ('present', 'absent', 'late', 'half_day')) DEFAULT 'present',
  notes TEXT,
  date DATE DEFAULT CURRENT_DATE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, date)
);

-- 2. LEAVE REQUESTS TABLE
CREATE TABLE leave_requests (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  leave_type TEXT CHECK (leave_type IN ('casual', 'sick', 'annual', 'maternity', 'emergency')) NOT NULL,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  days_requested INTEGER NOT NULL,
  reason TEXT,
  status TEXT CHECK (status IN ('pending', 'approved', 'rejected', 'cancelled')) DEFAULT 'pending',
  approved_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  approved_at TIMESTAMPTZ,
  rejection_reason TEXT,
  attachment_url TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. EMPLOYEE DOCUMENTS TABLE
CREATE TABLE employee_documents (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  document_name TEXT NOT NULL,
  document_type TEXT CHECK (document_type IN ('cv', 'id_card', 'contract', 'certificate', 'other')) NOT NULL,
  file_url TEXT NOT NULL,
  file_size INTEGER,
  file_type TEXT,
  expiry_date DATE,
  uploaded_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  is_confidential BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE attendance ENABLE ROW LEVEL SECURITY;
ALTER TABLE leave_requests ENABLE ROW LEVEL SECURITY;
ALTER TABLE employee_documents ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_attendance_user_date ON attendance(user_id, date);
CREATE INDEX idx_leave_requests_user_id ON leave_requests(user_id);
CREATE INDEX idx_leave_requests_status ON leave_requests(status);

-- =============================================
-- STEP 4: COMMUNICATION TABLES
-- =============================================

-- 1. CHANNELS TABLE
CREATE TABLE channels (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  type TEXT CHECK (type IN ('public', 'private', 'direct')) DEFAULT 'public',
  created_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  is_archived BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. CHANNEL MEMBERS TABLE
CREATE TABLE channel_members (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  channel_id UUID REFERENCES channels(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  role TEXT CHECK (role IN ('admin', 'member')) DEFAULT 'member',
  joined_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(channel_id, user_id)
);

-- 3. MESSAGES TABLE
CREATE TABLE messages (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  channel_id UUID REFERENCES channels(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  content TEXT,
  message_type TEXT CHECK (message_type IN ('text', 'file', 'image', 'system')) DEFAULT 'text',
  attachments TEXT[],
  mentions UUID[],
  thread_id UUID REFERENCES messages(id) ON DELETE CASCADE,
  is_edited BOOLEAN DEFAULT FALSE,
  edited_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE channels ENABLE ROW LEVEL SECURITY;
ALTER TABLE channel_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_messages_channel_id ON messages(channel_id);
CREATE INDEX idx_messages_created_at ON messages(created_at);

-- =============================================
-- STEP 5: TIME TRACKING TABLES
-- =============================================

-- 1. TIME ENTRIES TABLE
CREATE TABLE time_entries (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  project_id UUID REFERENCES projects(id) ON DELETE CASCADE,
  task_id UUID REFERENCES tasks(id) ON DELETE CASCADE,
  start_time TIMESTAMPTZ NOT NULL,
  end_time TIMESTAMPTZ,
  duration INTEGER, -- in seconds
  description TEXT,
  is_manual BOOLEAN DEFAULT FALSE,
  is_approved BOOLEAN DEFAULT FALSE,
  approved_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  screenshots TEXT[],
  activity_percentage INTEGER DEFAULT 0,
  keyboard_strokes INTEGER DEFAULT 0,
  mouse_clicks INTEGER DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 2. SCREENSHOTS TABLE
CREATE TABLE screenshots (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  time_entry_id UUID REFERENCES time_entries(id) ON DELETE CASCADE,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  file_url TEXT NOT NULL,
  thumbnail_url TEXT,
  captured_at TIMESTAMPTZ NOT NULL,
  activity_level INTEGER DEFAULT 0,
  is_blurred BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- 3. TIMESHEETS TABLE
CREATE TABLE timesheets (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  week_start_date DATE NOT NULL,
  week_end_date DATE NOT NULL,
  total_hours DECIMAL(5,2) DEFAULT 0,
  status TEXT CHECK (status IN ('draft', 'submitted', 'approved', 'rejected')) DEFAULT 'draft',
  submitted_at TIMESTAMPTZ,
  approved_by UUID REFERENCES profiles(id) ON DELETE SET NULL,
  approved_at TIMESTAMPTZ,
  rejection_reason TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(user_id, week_start_date)
);

-- Enable RLS
ALTER TABLE time_entries ENABLE ROW LEVEL SECURITY;
ALTER TABLE screenshots ENABLE ROW LEVEL SECURITY;
ALTER TABLE timesheets ENABLE ROW LEVEL SECURITY;

-- Indexes
CREATE INDEX idx_time_entries_user_id ON time_entries(user_id);
CREATE INDEX idx_time_entries_project_id ON time_entries(project_id);
CREATE INDEX idx_time_entries_start_time ON time_entries(start_time);

-- =============================================
-- STEP 6: NOTIFICATIONS & UTILITY FUNCTIONS
-- =============================================

-- 1. NOTIFICATIONS TABLE
CREATE TABLE notifications (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  type TEXT CHECK (type IN ('info', 'success', 'warning', 'error', 'mention', 'task', 'project')) DEFAULT 'info',
  is_read BOOLEAN DEFAULT FALSE,
  action_url TEXT,
  related_id UUID,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Enable RLS
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;

-- =============================================
-- EMAIL OTP UTILITY FUNCTIONS
-- =============================================

-- Function to clean up expired OTP codes
CREATE OR REPLACE FUNCTION cleanup_expired_otps()
RETURNS void AS $$
BEGIN
    DELETE FROM email_otp_codes WHERE expires_at < NOW();
    DELETE FROM password_reset_tokens WHERE expires_at < NOW();
END;
$$ LANGUAGE plpgsql;

-- Function to generate 6-digit OTP
CREATE OR REPLACE FUNCTION generate_otp()
RETURNS TEXT AS $$
BEGIN
    RETURN LPAD(FLOOR(RANDOM() * 1000000)::TEXT, 6, '0');
END;
$$ LANGUAGE plpgsql;

-- Function to create email OTP
CREATE OR REPLACE FUNCTION create_email_otp(
    p_email TEXT,
    p_purpose TEXT,
    p_user_id UUID DEFAULT NULL
)
RETURNS TABLE(otp_code TEXT, otp_id UUID) AS $$
DECLARE
    v_otp TEXT;
    v_otp_id UUID;
    v_expires_at TIMESTAMPTZ;
BEGIN
    -- Generate OTP
    v_otp := generate_otp();
    
    -- Set expiration (15 minutes from now)
    v_expires_at := NOW() + INTERVAL '15 minutes';
    
    -- Invalidate any existing OTPs for this email and purpose
    UPDATE email_otp_codes 
    SET is_verified = false 
    WHERE email = p_email AND purpose = p_purpose AND expires_at > NOW();
    
    -- Insert new OTP
    INSERT INTO email_otp_codes (email, otp_code, purpose, expires_at, user_id)
    VALUES (p_email, v_otp, p_purpose, v_expires_at, p_user_id)
    RETURNING id INTO v_otp_id;
    
    RETURN QUERY SELECT v_otp, v_otp_id;
END;
$$ LANGUAGE plpgsql;

-- Function to verify email OTP
CREATE OR REPLACE FUNCTION verify_email_otp(
    p_email TEXT,
    p_otp_code TEXT,
    p_purpose TEXT
)
RETURNS BOOLEAN AS $$
DECLARE
    v_otp_record RECORD;
BEGIN
    -- Get the OTP record
    SELECT * INTO v_otp_record
    FROM email_otp_codes
    WHERE email = p_email 
    AND purpose = p_purpose 
    AND otp_code = p_otp_code
    AND expires_at > NOW()
    AND is_verified = false
    AND attempt_count < max_attempts;
    
    IF NOT FOUND THEN
        -- Increment attempt count if record exists
        UPDATE email_otp_codes 
        SET attempt_count = attempt_count + 1
        WHERE email = p_email 
        AND purpose = p_purpose 
        AND expires_at > NOW();
        
        RETURN FALSE;
    END IF;
    
    -- Mark as verified
    UPDATE email_otp_codes
    SET is_verified = true, verified_at = NOW()
    WHERE id = v_otp_record.id;
    
    -- If this is email verification, update profile
    IF p_purpose = 'email_verification' THEN
        UPDATE profiles
        SET email_verified = true
        WHERE email = p_email;
    END IF;
    
    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;

-- Function to create password reset token
CREATE OR REPLACE FUNCTION create_password_reset_token(
    p_user_id UUID,
    p_email TEXT,
    p_otp_id UUID
)
RETURNS TEXT AS $$
DECLARE
    v_token TEXT;
BEGIN
    -- Generate secure token
    v_token := encode(gen_random_bytes(32), 'hex');
    
    -- Invalidate existing tokens for this user
    UPDATE password_reset_tokens
    SET is_used = true
    WHERE user_id = p_user_id AND is_used = false;
    
    -- Create new token
    INSERT INTO password_reset_tokens (user_id, email, token, otp_id, expires_at)
    VALUES (p_user_id, p_email, v_token, p_otp_id, NOW() + INTERVAL '1 hour');
    
    RETURN v_token;
END;
$$ LANGUAGE plpgsql;

-- Function to validate password reset token
CREATE OR REPLACE FUNCTION validate_reset_token(p_token TEXT)
RETURNS TABLE(user_id UUID, email TEXT, is_valid BOOLEAN) AS $$
DECLARE
    v_token_record RECORD;
BEGIN
    SELECT * INTO v_token_record
    FROM password_reset_tokens prt
    JOIN email_otp_codes eoc ON prt.otp_id = eoc.id
    WHERE prt.token = p_token
    AND prt.expires_at > NOW()
    AND prt.is_used = false
    AND eoc.is_verified = true;
    
    IF FOUND THEN
        RETURN QUERY SELECT v_token_record.user_id, v_token_record.email, true;
    ELSE
        RETURN QUERY SELECT NULL::UUID, NULL::TEXT, false;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- UTILITY FUNCTIONS AND TRIGGERS
-- =============================================

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE 'plpgsql';

-- Add triggers for updated_at
CREATE TRIGGER update_profiles_updated_at BEFORE UPDATE ON profiles 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_projects_updated_at BEFORE UPDATE ON projects 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_tasks_updated_at BEFORE UPDATE ON tasks 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_task_comments_updated_at BEFORE UPDATE ON task_comments 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_leave_requests_updated_at BEFORE UPDATE ON leave_requests 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =============================================
-- STEP 7: ROW LEVEL SECURITY POLICIES
-- =============================================

-- PROFILES POLICIES
CREATE POLICY "Users can view all profiles" ON profiles FOR SELECT USING (true);
CREATE POLICY "Users can update own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Admins can do everything" ON profiles FOR ALL USING (
  EXISTS (
    SELECT 1 FROM profiles 
    WHERE id = auth.uid() AND role IN ('admin', 'hr')
  )
);

-- EMAIL OTP POLICIES
CREATE POLICY "Users can access own email OTPs" ON email_otp_codes FOR ALL USING (
    email = (SELECT email FROM profiles WHERE id = auth.uid()) OR
    user_id = auth.uid()
);

-- PASSWORD RESET TOKEN POLICIES
CREATE POLICY "Users can access own reset tokens" ON password_reset_tokens FOR SELECT USING (
    user_id = auth.uid() OR
    email = (SELECT email FROM profiles WHERE id = auth.uid())
);

-- PROJECT POLICIES
CREATE POLICY "Users can view assigned projects" ON projects FOR SELECT USING (
  visibility = 'public' OR 
  assigned_to = auth.uid() OR 
  created_by = auth.uid() OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

CREATE POLICY "Users can create projects" ON projects FOR INSERT WITH CHECK (created_by = auth.uid());

CREATE POLICY "Project creators and admins can update" ON projects FOR UPDATE USING (
  created_by = auth.uid() OR 
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

-- TASK POLICIES
CREATE POLICY "Users can view project tasks" ON tasks FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM projects p 
    WHERE p.id = tasks.project_id AND (
      p.visibility = 'public' OR 
      p.assigned_to = auth.uid() OR 
      p.created_by = auth.uid() OR
      tasks.assigned_to = auth.uid()
    )
  ) OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

CREATE POLICY "Users can create tasks in their projects" ON tasks FOR INSERT WITH CHECK (
  EXISTS (
    SELECT 1 FROM projects p 
    WHERE p.id = tasks.project_id AND (
      p.created_by = auth.uid() OR 
      p.assigned_to = auth.uid()
    )
  ) OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

CREATE POLICY "Assigned users can update tasks" ON tasks FOR UPDATE USING (
  assigned_to = auth.uid() OR 
  created_by = auth.uid() OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

-- TASK COMMENTS POLICIES
CREATE POLICY "Users can view task comments" ON task_comments FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM tasks t
    JOIN projects p ON t.project_id = p.id
    WHERE t.id = task_comments.task_id AND (
      p.visibility = 'public' OR 
      p.assigned_to = auth.uid() OR 
      p.created_by = auth.uid() OR
      t.assigned_to = auth.uid()
    )
  ) OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

CREATE POLICY "Users can create comments" ON task_comments FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "Users can update own comments" ON task_comments FOR UPDATE USING (user_id = auth.uid());

-- PROJECT MEMBERS POLICIES
CREATE POLICY "Members can view project membership" ON project_members FOR SELECT USING (
  user_id = auth.uid() OR
  EXISTS (
    SELECT 1 FROM project_members pm 
    WHERE pm.project_id = project_members.project_id AND pm.user_id = auth.uid()
  ) OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

-- ATTENDANCE POLICIES
CREATE POLICY "Users can view own attendance" ON attendance FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "HR and admins can view all attendance" ON attendance FOR SELECT USING (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'hr', 'manager'))
);
CREATE POLICY "Users can insert own attendance" ON attendance FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "Users can update own attendance" ON attendance FOR UPDATE USING (user_id = auth.uid());

-- LEAVE REQUESTS POLICIES
CREATE POLICY "Users can view own leave requests" ON leave_requests FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "HR and managers can view all leave requests" ON leave_requests FOR SELECT USING (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'hr', 'manager'))
);
CREATE POLICY "Users can create leave requests" ON leave_requests FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "Users can update own pending requests" ON leave_requests FOR UPDATE USING (
  user_id = auth.uid() AND status = 'pending'
);
CREATE POLICY "HR can approve/reject requests" ON leave_requests FOR UPDATE USING (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'hr', 'manager'))
);

-- EMPLOYEE DOCUMENTS POLICIES
CREATE POLICY "Users can view own documents" ON employee_documents FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "HR can view all documents" ON employee_documents FOR SELECT USING (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'hr'))
);
CREATE POLICY "HR can upload documents" ON employee_documents FOR INSERT WITH CHECK (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'hr')) OR
  user_id = auth.uid()
);

-- CHANNELS POLICIES
CREATE POLICY "Users can view public channels" ON channels FOR SELECT USING (
  type = 'public' OR
  EXISTS (
    SELECT 1 FROM channel_members cm 
    WHERE cm.channel_id = channels.id AND cm.user_id = auth.uid()
  ) OR
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin'))
);

-- CHANNEL MEMBERS POLICIES
CREATE POLICY "Users can view channel membership" ON channel_members FOR SELECT USING (
  user_id = auth.uid() OR
  EXISTS (
    SELECT 1 FROM channel_members cm 
    WHERE cm.channel_id = channel_members.channel_id AND cm.user_id = auth.uid()
  )
);

-- MESSAGES POLICIES
CREATE POLICY "Channel members can view messages" ON messages FOR SELECT USING (
  EXISTS (
    SELECT 1 FROM channels c
    LEFT JOIN channel_members cm ON c.id = cm.channel_id
    WHERE c.id = messages.channel_id AND (
      c.type = 'public' OR
      cm.user_id = auth.uid()
    )
  )
);

CREATE POLICY "Channel members can send messages" ON messages FOR INSERT WITH CHECK (
  user_id = auth.uid() AND
  EXISTS (
    SELECT 1 FROM channels c
    LEFT JOIN channel_members cm ON c.id = cm.channel_id
    WHERE c.id = messages.channel_id AND (
      c.type = 'public' OR
      cm.user_id = auth.uid()
    )
  )
);

-- TIME ENTRIES POLICIES
CREATE POLICY "Users can view own time entries" ON time_entries FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Managers can view team time entries" ON time_entries FOR SELECT USING (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);
CREATE POLICY "Users can create time entries" ON time_entries FOR INSERT WITH CHECK (user_id = auth.uid());
CREATE POLICY "Users can update own time entries" ON time_entries FOR UPDATE USING (user_id = auth.uid());

-- SCREENSHOTS POLICIES
CREATE POLICY "Users can view own screenshots" ON screenshots FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Managers can view team screenshots" ON screenshots FOR SELECT USING (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);

-- TIMESHEETS POLICIES
CREATE POLICY "Users can view own timesheets" ON timesheets FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Managers can view team timesheets" ON timesheets FOR SELECT USING (
  EXISTS (SELECT 1 FROM profiles WHERE id = auth.uid() AND role IN ('admin', 'manager'))
);
CREATE POLICY "Users can manage own timesheets" ON timesheets FOR ALL USING (user_id = auth.uid());

-- NOTIFICATIONS POLICIES
CREATE POLICY "Users can view own notifications" ON notifications FOR SELECT USING (user_id = auth.uid());
CREATE POLICY "Users can update own notifications" ON notifications FOR UPDATE USING (user_id = auth.uid());

-- =============================================
-- CLEANUP JOB (Optional - run periodically)
-- =============================================

-- Create a function to be called by a cron job to clean expired records
CREATE OR REPLACE FUNCTION cleanup_expired_records()
RETURNS void AS $$
BEGIN
    -- Clean expired OTPs
    DELETE FROM email_otp_codes WHERE expires_at < NOW();
    
    -- Clean expired password reset tokens
    DELETE FROM password_reset_tokens WHERE expires_at < NOW();
    
    -- Clean old unverified OTPs (older than 24 hours)
    DELETE FROM email_otp_codes 
    WHERE is_verified = false 
    AND created_at < NOW() - INTERVAL '24 hours';
END;
$$ LANGUAGE plpgsql;